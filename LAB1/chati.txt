package main

import (
	"bufio"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

type TCPServer struct{
	MaxConn int
}

func (s *TCPServer) Listen(addr string) error {
	l, err := net.Listen("tcp", addr)
	if err != nil {
		return fmt.Errorf("failed to listen to %s", addr)
	}
	defer l.Close()

	channel := make(chan struct{}, s.MaxConn)

	for {
		conn, err := l.Accept()
		if err != nil {
			fmt.Println("accept error:", err)
			continue
		}

		channel <- struct{}{} // take spot
		go s.handler(conn, channel)
	}
}

// Handling for one connection
func (s *TCPServer) handler(conn net.Conn, channel chan struct{}) {

	defer func() {
		conn.Close()
		<-channel // release spot
	}()

	msg := bufio.NewReader(conn)
	req, err := http.ReadRequest(msg)
	if err != nil {
		resp := newBadRequestResp400("400 Bad Request\n")
		resp.Write(conn)
		return
	}

	if req.Method == "GET" {
		s.getHandler(conn, req)
	} else if req.Method == "POST" {
		s.postHandler(conn, req)
	} else {
		resp := newNotImplementedResp501()
		resp.Write(conn)
		return
	}
}

// ---------------- GET ----------------

func (s *TCPServer) getHandler(conn net.Conn, req *http.Request) {
    ext := filepath.Ext(req.URL.Path)  // /kiend.hmtl -> .html 
	filename := "." + req.URL.Path   // ./kiend.html 
	
	var contentType string
	switch ext {
	case ".html":
		contentType = "text/html"
	case ".txt":
		contentType = "text/plain"
	case ".gif":
		contentType = "image/gif"
	case ".jpeg", ".jpg":
		contentType = "image/jpeg"
	case ".css":
		contentType = "text/css"
	default:
		resp := newBadRequestResp400("400 Bad Request (unsupported extension)\n")
		resp.Write(conn)
		return
	}
	// open filename if error respond with 404  
	f, err := os.Open(filename)
	if err != nil {
		resp := newNotFoundResp404()
		resp.Write(conn)
		return
	}
	defer f.Close()

	info, _ := f.Stat()
	size := info.Size()

	resp := http.Response{
		Status:        "200 OK",
		StatusCode:    200,
		Proto:         "HTTP/1.1",
		ProtoMajor:    1,
		ProtoMinor:    1,
		Header:        make(http.Header),
		Body:          f,
		ContentLength: size,
	}
	resp.Header.Set("Content-Type", contentType)
	resp.Write(conn)
}

// ---------------- POST ----------------

func (s *TCPServer) postHandler(conn net.Conn, req *http.Request) {

	defer req.Body.Close()
	
	ext := filepath.Ext(req.URL.Path)  // /kiend.html -> .html
	filename := "." + req.URL.Path     // ./kiend.html


	// decide content-type with switch
	var contentType string
	switch ext {
	case ".html":
		contentType = "text/html"
	case ".txt":
		contentType = "text/plain"
	case ".gif":
		contentType = "image/gif"
	case ".jpeg", ".jpg":
		contentType = "image/jpeg"
	case ".css":
		contentType = "text/css"
	default:
		resp := newBadRequestResp400("Bad Request\n")
		resp.Write(conn)
		return
	}

	bodyBytes, err := io.ReadAll(req.Body)  // req.Body is an io.ReadCloser, i.e. a readable stream (like a file or network socket).  io.ReadAll() is a helper that reads the entire stream into memory and returns it as a []byte.
	if err != nil {
		resp := newBadRequestResp400("Error reading body\n")
		resp.Write(conn)
		return
	}

	// create all dir and parent dirs (if needed /folder/kiend.html) 0= base oct 7 = user{4+2+1 = read,write,ex}, 5 = group{4+0+1=read,,execute} , 5 = others{4+0+1=read,,execute}
	os.MkdirAll(filepath.Dir(filename), 0755)

	err = os.WriteFile(filename, bodyBytes, 0644)  // 0 = base oct 5 = user{4+2+0 = read,write,}, 4 = group{4+0+0=read,,} , 4 = others{4+0+0=read,,}
	if err != nil {
		resp := newInternalErrorResp500()
		resp.Write(conn)
		return
	}

	resp := http.Response{
		Status:        "201 Created",
		StatusCode:    201,
		Proto:         "HTTP/1.1",
		ProtoMajor:    1,
		ProtoMinor:    1,
		Header:        make(http.Header),
		ContentLength: int64(len(bodyBytes)),
		Body:          io.NopCloser(strings.NewReader("File saved successfully\n")),
	}
	resp.Header.Set("Content-Type", contentType)
	resp.Write(conn)
}

// ------------- helpers for errors -------------

func newBadRequestResp400(msg string) http.Response {
	return http.Response{
		Status:     "400 Bad Request",
		StatusCode: 400,
		Proto:      "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header:     make(http.Header),
		Body:       io.NopCloser(strings.NewReader(msg)),
	}
}

func newNotImplementedResp501() http.Response {
	return http.Response{
		Status:     "501 Not Implemented",
		StatusCode: 501,
		Proto:      "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header:     make(http.Header),
		Body:       io.NopCloser(strings.NewReader("501 Not Implemented\n")),
	}
}

func newNotFoundResp404() http.Response {
	return http.Response{
		Status:     "404 Not Found",
		StatusCode: 404,
		Proto:      "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header:     make(http.Header),
		Body:       io.NopCloser(strings.NewReader("404 Not Found\n")),
	}
}

func newInternalErrorResp500() http.Response {
	return http.Response{
		Status:     "500 Internal Server Error",
		StatusCode: 500,
		Proto:      "HTTP/1.1",
		ProtoMajor: 1,
		ProtoMinor: 1,
		Header:     make(http.Header),
		Body:       io.NopCloser(strings.NewReader("Error saving file\n")),
	}
}

// ------------- main -------------

func main() {
	if len(os.Args) < 2 {
		fmt.Println("One arg required: (port)")
		return
	}
	port := os.Args[1]

	s := &TCPServer{MaxConn: 10}  // 10 connections 
	if err := s.Listen(":" + port); err != nil {
		fmt.Println("error:", err)
	}
}


/* 

func (s *TCPServer) newResponse(statusCode int, body string) http.Response {
    return http.Response{
        Status:     fmt.Sprintf("%d %s", statusCode, http.StatusText(statusCode)),
        StatusCode: statusCode,
        Proto:      "HTTP/1.1",
        ProtoMajor: 1,
        ProtoMinor: 1,
        Header:     make(http.Header),
        Body:       io.NopCloser(strings.NewReader(body)),
    }
}



*/
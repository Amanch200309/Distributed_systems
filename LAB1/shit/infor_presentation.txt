
//hur channels funkar
Go provides a unique concurrency synchronization technique, channel. Channels make goroutines share memory by communicating. 
We can view a channel as an internal FIFO (first in, first out) queue within a program. Some goroutines send values to the 
queue (the channel) and some other goroutines receive values from the queue.

channel <- struct{}{} // take spot

go s.handler(conn, channel) // startar hanteringen i en gorutin

// I handler frigÃ¶rs platsen nÃ¤r jobbet Ã¤r klart
defer func() {
    conn.Close()
    <-channel // lÃ¤mna tillbaka platsen
}()

///////////////////////////////////
Din kanal Ã¤r en biljett-pool:
Skapande:
channel := make(chan struct{}, 10) â†’ poolen rymmer 10 biljetter.
Innan en gorutin startar:
channel <- struct{}{} â†’ gorutinen tar en biljett.
Om poolen Ã¤r tom (alla 10 upptagna) blockerar raden tills nÃ¥gon lÃ¤mnar tillbaka en.
NÃ¤r gorutinen Ã¤r klar (i handler):
<-channel â†’ biljetten lÃ¤mnas tillbaka â†’ en ny gorutin kan bÃ¶rja.
Detta garanterar max 10 samtidigt aktiva hanteringar.
Det Ã¤r precis sÃ¥ en semafor/ticket-pool ska anvÃ¤ndas i Go, och ditt upplÃ¤gg Ã¤r idiomatiskt.


///////////////////////
./httpserver 8080           

printar variabel req line 55      
Received request: &{GET /index.html HTTP/1.1 1 1 map[Accept:[*/*] User-Agent:[curl/8.12.1]] 
{} <nil> 0 [] false localhost:8080 map[] map[] <nil> map[]  /index.html <nil> <nil> <nil>  <nil> <nil> [] map[]}

frÃ¥n curl http://localhost:8080/index.html

///////////////////////
varfÃ¶r buferio?

ğŸ§± Mer konkret: utan buffring vs med buffring
ğŸ”´ Utan buffrad lÃ¤sare

Om du lÃ¤ser direkt frÃ¥n conn:

buf := make([]byte, 1)
conn.Read(buf)


â€¦dÃ¥ ber du operativsystemet:

â€œGe mig 1 byte frÃ¥n nÃ¤tverket.â€

Om klienten (t.ex. curl) skickar 500 byte, sÃ¥ mÃ¥ste du anropa Read() 500 gÃ¥nger fÃ¶r att lÃ¤sa hela meddelandet.

ğŸ’€ Det blir segt och dyrt â€” varje Read() innebÃ¤r ett systemanrop.

ğŸŸ¢ Med buffrad lÃ¤sare

Om du istÃ¤llet gÃ¶r:

msg := bufio.NewReader(conn)
b, _ := msg.ReadBytes('\n')

DÃ¥ hÃ¤mtar Go en stor klump data (t.ex. 4 KB) frÃ¥n nÃ¤tverket i ett enda systemanrop, sparar det i en buffert i minnet, 
och sen kan du lÃ¤sa rader, bytes, etc. frÃ¥n den snabbt â€“ utan att behÃ¶va gÃ¥ till nÃ¤tverkskortet igen.

////////////////////////////////////////

Varje gÃ¥ng du Ã¶ppnar nÃ¥got (fil, nÃ¤tverk, request body)
â†’ mÃ¥ste du stÃ¤nga det.

Annars ligger det kvar i bakgrunden och tar upp resurser.

/////////////////////////////////////////
